from subprocess import call, PIPE, Popen
import sys, time, random
ON_POSIX = 'posix' in sys.builtin_module_names
from threading import Thread
#from Queue import Thread

# ALL COORDS ARE FOR HTC M8
escape_pokemon_loc = [100,150]
nominal_player_loc = [540,1300]
main_menu_loc = [540,1650]
MAX_X = 1080
MAX_Y = 1920
GETEVENT_MAX_X = 1620
GETEVENT_MAX_Y = 2880

def translate_getevent_coords(x,y):
	dispX = (x*MAX_X) / (GETEVENT_MAX_X+1)
	dispY = (y*MAX_Y) / (GETEVENT_MAX_Y+1)
	return [dispX,dispY]
	
def translate_x(x):
	return (x*MAX_X) / (GETEVENT_MAX_X+1)
	
def translate_y(y):
	return (y*MAX_Y) / (GETEVENT_MAX_Y+1)

left_swipe_cmd = ['adb','shell','input','swipe','300','800','600','800','165']
right_swipe_cmd = ['adb','shell','input','swipe','600','800','300','800','165']

pokestop_degsEON = 240
ten_deg_swipe_cmd = ['adb','shell','input','swipe','588','800','712','800','200']

simple_quit_cmd = ['adb','shell','am','force-stop','com.nianticlabs.pokemongo']
simple_start_cmd = ['adb','shell','monkey','-p','com.nianticlabs.pokemongo','-c','android.intent.category.LAUNCHER','1']
safety_alert_ok_btn_loc = [540,1000]
login_fail_retry_btn_loc = [540,1000]

# quit & restart procedure
press_home_button_cmd = ['adb','shell','input','keyevent','3']
settings_shortcut_loc = [205,950]
settings_swipetoapps_cmd = ['adb','shell','input','swipe','540','1500','540','300','200']
apps_option_loc_in_settings_after_swipe = [540,1050]
apps_list_smallswipe_cmd = ['adb','shell','input','swipe','540','1400','540','400','200']
app_list_swipes = 8
pokemon_loc_in_apps_list_after_swipes = [540,650]
force_stop_loc = [800,500]
force_stop_confirm_loc = [800,1100]
pokemon_shortcut_loc = [875,950]
approx_restart_time_seconds = 20

def simple_restart():
	do_cmd(simple_quit_cmd)
	time.sleep(4)
	do_cmd(simple_start_cmd)
	time.sleep(30)
	
	# sometimes, it'll log in OK which means we're at the
	# safety alert button.  other times, we'll have login
	# failure and be at the retry button.  Those buttons
	# are in the same location, so we'll just press it a
	# couple of times either way.  This will be fine as
	# long as there are no pokestops, pokemon, or gyms at
	# the same pixel location as the retry button.
	for i in range(5):
		do_tap(*safety_alert_ok_btn_loc)
		time.sleep(12)

def quit_and_restart():
	do_cmd(press_home_button_cmd)
	time.sleep(5)
	do_tap(*settings_shortcut_loc)
	time.sleep(3)
	do_cmd(settings_swipetoapps_cmd)
	time.sleep(3)
	do_tap(*apps_option_loc_in_settings_after_swipe)
	time.sleep(3)
	for i in range(app_list_swipes):
		do_cmd(apps_list_smallswipe_cmd)
		time.sleep(2)
	do_tap(*pokemon_loc_in_apps_list_after_swipes)
	time.sleep(4)
	do_tap(*force_stop_loc)
	time.sleep(4)
	do_tap(*force_stop_confirm_loc)
	time.sleep(10)
	do_cmd(press_home_button_cmd)
	time.sleep(4)
	do_tap(*pokemon_shortcut_loc)
	time.sleep(approx_restart_time_seconds*2)
	# TODO swipe to look at the pokestop

def do_left_swipe(blocking=True):
	do_cmd(left_swipe_cmd,blocking)
	
def do_right_swipe(blocking=True):
	do_cmd(right_swipe_cmd,blocking)
	
def do_tap(x,y,blocking=True):
	do_cmd(['adb','shell','input','tap',str(x),str(y)],blocking)

def do_cmd(token_list,blocking=True):
	if blocking: call(token_list)
	else: Popen(token_list, close_fds=ON_POSIX)
	
STATE_POKESTOP = 'PokestopState'
STATE_POKESTOP_SPINREADY = 'PokestopSpinnerInteractionState'
STATE_ENCOUNTER = 'WildPokemonEncounterState'
STATE_GYM = 'GymState'
STATE_MAP = 'MapExploreState'
		
		
class StateChangeMonitor(object):
	state = STATE_MAP
	def __init__(self): pass
	
	def monitor_thread(self):
		# clear out log first
		call(['adb','logcat','-c'])
	
		# pipe the info-level messages
		p = Popen(['adb','logcat','*:I'], stdout=PIPE, bufsize=1, close_fds=ON_POSIX)
	
		# listen for any state changes
		for line in iter(p.stdout.readline, b''):
	
			# handle Map --> ? cases
			if self.state == STATE_MAP:
				if STATE_POKESTOP in line:
					self.state = STATE_POKESTOP
					print(self.state)
				elif STATE_ENCOUNTER in line:
					self.state = STATE_ENCOUNTER
					print(self.state)
				elif STATE_GYM in line:
					self.state = STATE_GYM
					print(self.state)
		
			# handle ? --> Map case
			elif self.state == STATE_ENCOUNTER:
				lookingFor = "transitioned to child state " + STATE_MAP
				if lookingFor in line:
					self.state = STATE_MAP
					print(self.state)
			else:
				lookingFor = STATE_MAP + " cleared child state"
				if lookingFor in line:
					self.state = STATE_MAP
					print(self.state)
		
		
def tap_test_pattern():
	for i in range(7):
		for j in range(7):
			do_tap(100+(i*110),400+(j*110))
			
def grab_items():
	print("attempting to grab items...")
	for i in range(10):
		x = 100 + (i*100)
		for j in range(6):
			y = 1000 + (j*100)
			do_tap(x,y)
			
def grab_items_relaxed():
	# they float to the top and get collected either way.
	# this is more of a keep-alive while we wait for them to float up
	for i in range(5):
		do_tap(100 + (i*150), 1000)
		time.sleep(5)

			
class ActualTouchMonitor(object):
	last_touch_pos = None
	temp_x = None
	temp_y = None
	has_new_x = False
	has_new_y = False
	def __init__(self,evtNum):
		self.evtNum = str(evtNum)
	
	def has_new(self): return self.has_new_x and self.has_new_y
	
	def use_last_touch_pos(self):
		self.has_new_x = False
		self.has_new_y = False
		return self.last_touch_pos
		
	@staticmethod
	def get_touch_monitor():
		atms = []
		atm_ts = []
		for i in range(6):
			atm = ActualTouchMonitor(i)
			atm_t = Thread(target=atm.monitor_thread)
			atm_t.daemon = True
			atms.append(atm)
			atm_ts.append(atm_t)
		for atm_t in atm_ts: atm_t.start()
		print("Please touch the screen within 5 seconds...")
		time.sleep(5)
		for atm in atms:
			if atm.has_new():
				atm.use_last_touch_pos()
				print("event"+atm.evtNum+" file crrently handles touch events")
				return atm
			
		return None
	
	def monitor_thread(self):
		print("user-touch monitor thread starts...")
		p = Popen(['adb','shell','getevent','-l','/dev/input/event'+self.evtNum],
							stdout=PIPE, bufsize=1, close_fds=ON_POSIX)
		
		# listen for user touches
		for line in iter(p.stdout.readline, b''):
			#print(line)
			if "ABS_MT_POSITION_X" in line:
				#print(line)
				hexStr = line.split()[-1].strip()
				self.temp_x = translate_x(int(hexStr,16))
				self.has_new_x = True
				if self.has_new():
					self.last_touch_pos = [self.temp_x,self.temp_y]
					print(self.last_touch_pos)
			elif "ABS_MT_POSITION_Y" in line:
				#print(line)
				hexStr = line.split()[-1].strip()
				self.temp_y = translate_y(int(hexStr,16))
				self.has_new_y = True
				if self.has_new():
					self.last_touch_pos = [self.temp_x,self.temp_y]
					print(self.last_touch_pos)
				
			
class GameState(object):
	state = STATE_MAP # one would assume
	last_known_pokestop_loc = None
	search_iter = 0
	spin_left = True
	last_search_pos = None
	force_stop = False
	
	SEARCH_X_START = 340
	SEARCH_Y_START = 975
	SEARCH_X_STEP = 200
	SEARCH_Y_STEP = 50
	SEARCH_X_NUM_STEPS = 3
	SEARCH_Y_NUM_STEPS = 1
	FAIL_SEARCH_ROTATE = ['adb','shell','input','swipe','200','500','800','500','180']
	TIME_TO_RESTART = 2000
	
	def __init__(self,stateChangeMonitor,userTouchMonitor):
		self.stateChangeMonitor = stateChangeMonitor
		self.userTouchMonitor = userTouchMonitor
		self.uptime_ref = int(time.time())
		
	def do_quit_and_restart(self):
		'''
		quit_and_restart()
		self.state = STATE_MAP
		self.last_known_pokestop_loc = None
		self.search_iter = 0
		self.spin_left = True
		self.last_search_pos = None
		'''
		# use the above block if you feel brave.
		# for now, let's just call it a day.
		force_stop = True
		
	def get_state(self): return self.stateChangeMonitor.state
		
	def next(self):
		print("state is "+self.get_state())
	
		# nominal map state
		if self.get_state() == STATE_MAP:
		
			# measure the uptime and do a restart if necessary
			uptime = int(time.time()) - self.uptime_ref
			if(uptime > self.TIME_TO_RESTART):
				print("going down for a restart...")
				simple_restart()
				self.uptime_ref = int(time.time())
				self.last_known_pokestop_loc = None
				return
		
			if self.last_known_pokestop_loc is None:
				# search mode
			
				x_loc = self.SEARCH_X_START + ((self.search_iter % self.SEARCH_X_NUM_STEPS) * self.SEARCH_X_STEP)
				y_loc = self.SEARCH_Y_START + (int(self.search_iter/self.SEARCH_X_NUM_STEPS) * self.SEARCH_Y_STEP)
				print("polling location "+str(x_loc)+","+str(y_loc))
				do_tap(x_loc,y_loc)
				self.last_search_pos = [x_loc,y_loc]
				time.sleep(1)
				
				self.search_iter = (self.search_iter+1) % (self.SEARCH_X_NUM_STEPS*self.SEARCH_Y_NUM_STEPS)
				if self.search_iter == 0:
					
					# we must've gone off the rails. we must rotate and try again
					do_cmd(self.FAIL_SEARCH_ROTATE)
					
			else:
				# we still have a lock on the pokestop.
				# sleep for a bit then hit it again
				waitFor = random.randrange(25,45)
				print("the pokestop will be tapped again in "+str(waitFor)+" seconds.")
				time.sleep(waitFor)
				do_tap(*self.last_known_pokestop_loc)
				time.sleep(5)
				if self.get_state() != STATE_POKESTOP:
					print("lost the pokestop location!")
					print("last known location was "+str(self.last_known_pokestop_loc))
					# damn, we lost track of it
					self.last_known_pokestop_loc = None
					
	
		elif self.get_state() == STATE_POKESTOP:
			self.search_iter = 0 # if we got here from search mode
			if self.last_known_pokestop_loc is None:
				if self.userTouchMonitor.has_new():
					self.last_known_pokestop_loc = self.userTouchMonitor.use_last_touch_pos()
					print("pokestop location set by user")
				else:
					# hey hey, we actually found it! (well, maybe)
					# TODO: somehow we need to verify that this IS the fountain
					# and NOT northrop, the mclean metro stop, or westgate park!!!
					self.last_known_pokestop_loc = self.last_search_pos
					print("found pokestop location")
			
			# spin it to win it
			time.sleep(4)
			if self.spin_left: do_cmd(left_swipe_cmd)
			else: do_cmd(right_swipe_cmd)
			self.spin_left = not self.spin_left
			time.sleep(3) # wait for pokeballs to appear
			
			# pick up all the balls
			#grab_items()
			grab_items_relaxed()
			
			# exit the pokestop
			exitAttempts = 0
			while self.get_state() == STATE_POKESTOP:
				exitAttempts += 1
				print("pokestop exit attempt #"+str(exitAttempts)+"...")
				if exitAttempts > 15:
					self.do_quit_and_restart()
					break
				do_tap(*main_menu_loc)
				time.sleep(1)
			
		elif self.get_state() == STATE_ENCOUNTER:
			# DO NOT WANT!
			exitAttempts = 0
			while self.get_state() == STATE_ENCOUNTER:
				exitAttempts += 1
				if exitAttempts > 15:
					self.do_quit_and_restart()
					break
				do_tap(*escape_pokemon_loc)
				time.sleep(1)
			
		elif self.get_state() == STATE_GYM:
			# this would be tricky to automate. back out.
			exitAttempts = 0
			while self.get_state() == STATE_GYM:
				exitAttempts += 1
				if exitAttempts > 15:
					self.do_quit_and_restart()
					break
				do_tap(*main_menu_loc)
				time.sleep(1)
					

'''
This is the "complex" exploit script.

It should be started in the map-explore state.
It will try to find a pokestop by issuing tap events,
or the user can show it where the pokestop is by tapping
it themself.

It will perform a swipe on the pokestop and issue tap
events trying to collect items.  Then it will exit back
out to the map-explore state, wait a random amount of time,
re-enter the same pokestop, swipe again, so on and so forth.
'''				
def run_exploit_script():
	print("initializing pokestop exploitation script...")

	'''
	atm = ActualTouchMonitor()
	atm_t = Thread(target=atm.monitor_thread)
	atm_t.daemon = True
	atm_t.start()
	'''
	atm = ActualTouchMonitor.get_touch_monitor()
	if atm is None:
		print("No user-touch monitor could be established.  exiting...")
		return
	
	scm = StateChangeMonitor()
	scm_t = Thread(target=scm.monitor_thread)
	scm_t.daemon = True
	scm_t.start()
	
	#while True: time.sleep(1)
	
	# start GameState instance
	gs = GameState(scm,atm)
	print("ready.")
	while not gs.force_stop: gs.next()
	
	
'''
This is the "simple" exploit script.

It should be started after the user taps a pokestop,
and the script will simply perform a swipe gesture at
random intervals.
'''
def run_simple_exploit_script():
	
	# loop forever
	while True:
	
		# perform a swipe in a random direction
		if random.randrange(2): do_cmd(left_swipe_cmd)
		else: do_cmd(right_swipe_cmd)
	
		# wait for a random amount of time
		# keep it under a minute in case the device dims or
		# goes to sleep in that time
		time.sleep(random.randrange(30,59))
		
		
if __name__ == "__main__":
	run_exploit_script()
	#run_simple_exploit_script()